{% extends "booker/_booker_base.html" %}

{% block title %}
    {% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}) for {{ event_slug }}{% else %}Create New Segment for {{ event_slug }}{% endif %}
{% endblock %}

{% block content %}
<div class="header-bar">
    <h2>{% if segment.get('position') %}Edit Segment (Pos: {{ segment.get('position') }}){% else %}Create New Segment{% endif %} for {{ event_slug }}</h2>
    <div class="action-buttons">
        <a href="{{ url_for('events.edit_event', event_name=event_slug) }}">Back to Event</a>
    </div>
</div>

<form id="segment-form" class="wide-form" method="POST" action="{{ url_for('segments.create_segment', event_slug=event_slug) if not edit_mode else url_for('segments.edit_segment', event_slug=event_slug, position=original_position) }}">
    <fieldset class="form-section">
        <legend</h3>Segment Details</h3></legend>
        <div class="form-row">
            <div class="form-group">
                <label for="position">Position <span class="required">*</span></label>
                <input type="number" id="position" name="position" value="{{ segment.get('position', '') }}" required min="1">
            </div>
            <div class="form-group">
                <label for="type">Type <span class="required">*</span></label>
                <select id="type" name="type" required onchange="toggleMatchFields();">
                    <option value="">--Select Type--</option>
                    {% for seg_type in segment_type_options %}
                        <option value="{{ seg_type }}" {% if segment.get('type', '') == seg_type %}selected{% endif %}>{{ seg_type }}</option>
                    {% endfor %}
                </select>
            </div>
        </div>
        <div class="form-group">
            <label for="header">Header</label>
            <input type="text" id="header" name="header" value="{{ segment.get('header', '') }}">
            <small>Leave blank for matches to auto-generate (e.g., 'Singles Match').</small>
        </div>
    </fieldset>

    <div id="match-specific-fields" style="display: none;">
        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Participants Builder</h3></legend>
            <div class="form-group">
                <label for="participant-select">Add Participant to Current Side:</label>
                <div class="participant-adder">
                    <select id="participant-select">
                        <option value="">-- Select Participant --</option>
                        <optgroup label="Wrestlers">
                            {% for wrestler in all_wrestlers %}
                                <option value="wrestler:{{ wrestler.Name }}">{{ wrestler.Name }}</option>
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Tag Teams">
                             {% for team in all_tagteams %}
                                <option value="tagteam:{{ team.Name }}" data-members="{{ team.Members | tojson }}">{{ team.Name }}</option>
                            {% endfor %}
                        </optgroup>
                    </select>
                    <button type="button" class="btn btn-secondary" onclick="addParticipantToCurrentSide()">Add Participant</button>
                </div>
                <button type="button" class="btn btn-info" onclick="addNewSide()">Add VS. Side</button>
            </div>
            <div id="match-sides-container"></div>
            <p><h4>Participants Display:</h4> <span id="current-participants-display"></span></p>
            <input type="hidden" id="participants_display_input" name="participants_display" value="{{ match_data.get('participants_display', '') }}">
            <input type="hidden" id="match_sides_json_input" name="match_sides_json" value="{{ match_data.get('sides', []) | tojson | safe }}">
            <input type="hidden" id="match_results_json_input" name="match_results_json" value="{{ {'winning_side_index': match_data.winning_side_index, 'individual_results': match_data.individual_results, 'team_results': match_data.team_results, 'sync_teams_to_individuals': match_data.sync_teams_to_individuals} | tojson | safe }}">
        </fieldset>
        
        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Details</h3></legend>
            <div class="form-group">
                <label for="match_championship">Championship on the line</label>
                <select id="match_championship" name="match_championship" onchange="updateChampionDisplay()">
                    <option value="">-- None --</option>
                    {% for belt in all_belts %}
                        {% if belt.Status == 'Active' %}
                            <option value="{{ belt.Name }}" {% if match_data.get('match_championship') == belt.Name %}selected{% endif %}>
                                {{ belt.Name }}
                            </option>
                        {% endif %}
                    {% endfor %}
                </select>
                <p id="current-champion-display" class="form-static-text"></p>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="match_time">Match Time (MM:SS)</label>
                    <input type="text" id="match_time" name="match_time" value="{{ match_data.get('match_time', '') }}" pattern="^\d{1,2}:\d{2}$" placeholder="e.g., 05:30">
                </div>
                 <div class="form-group">
                    <input type="hidden" name="match_class" id="match_class_input" value="{{ match_data.get('match_class', '') }}">
                </div>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_from_card" name="hide_from_card_checkbox" {% if match_data.get('match_visibility', {}).get('hide_from_card', False) %}checked{% endif %}>
                <label for="hide_from_card">Match hidden from card</label>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_summary" name="hide_summary_checkbox" {% if match_data.get('match_visibility', {}).get('hide_summary', False) %}checked{% endif %}>
                <label for="hide_summary">Match summary hidden from event summary</label>
            </div>
            <div class="form-group">
                <input type="checkbox" id="hide_result" name="hide_result_checkbox" {% if match_data.get('match_visibility', {}).get('hide_result', False) %}checked{% endif %}>
                <label for="hide_result">Match result hidden from card</label>
            </div>
            <input type="hidden" id="match_visibility_json_input" name="match_visibility_json" value="{{ match_data.get('match_visibility', {}) | tojson | safe }}">
        </fieldset>

        <hr class="section-divider">
        <fieldset class="form-section">
            <legend><h3>Match Results</h3></legend>

            <!-- Overall match result -->
            <div class="form-group">
                <label for="match_result_overall">Overall Match Result</label>
                <select id="match_result_overall" name="match_result" class="form-control"></select>
                <small class="text-muted">Choose the overall outcome. Weâ€™ll generate the display string later.</small>
            </div>

            <!-- Winner method (only shown if match_result is a win) -->
            <div class="form-group" id="winner-method-group" style="display: none;">
                <label for="winner_method">Winning Method</label>
                <select id="winner_method" name="winner_method" class="form-control">
                    <option value="">-- Select Method --</option>
                    {% for method in winner_method_options %}
                        <option value="{{ method }}" {% if match_data.get('winner_method','') == method %}selected{% endif %}>{{ method|capitalize }}</option>
                    {% endfor %}
                </select>
                <small class="text-muted">Only required if the match has a winner.</small>
            </div>

            <!-- Note: The explicit "Winning Side" dropdown has been removed.
                 winning_side_index is now derived from the overall result. -->
            
            <div class="form-group mt-3">
                <label for="match_result_display">Match Result Display String</label>
                <textarea id="match_result_display" name="match_result_display" class="form-control" rows="3">{{ match_data.get('match_result_display', '') }}</textarea>
                <small class="text-muted">This string is auto-generated but can be manually edited.</small>
            </div>

            <div id="individual-results-container" class="results-container mt-3"></div>
            <div id="team-results-container" class="results-container"></div>
            <div class="form-group mt-2">
                <input type="checkbox" id="sync_teams_to_individuals" name="sync_teams_to_individuals" onchange="updateSyncToggle(this)" {% if match_data.get('sync_teams_to_individuals', True) %}checked{% endif %}>
                <label for="sync_teams_to_individuals">Sync Team Results to Individual Members</label>
            </div>
        </fieldset>
    </div>

    <fieldset class="form-section">
        <legend><h3>Summary</h3></legend>
        <div class="form-group">
            <label for="summary_text">Summary Text</label>
            <textarea id="summary_text" name="summary_text" rows="8">{{ summary_content | default('') }}</textarea>
        </div>
    </fieldset>

    <div class="action-buttons form-actions">
        <button type="button" class="btn btn-info" id="ai-assistant-btn">Generate with AI Assistant</button>
        <button type="submit" class="btn btn-primary">
            {% if segment.get('position') %}Update Segment{% else %}Create Segment{% endif %}
        </button>
        <a href="{{ url_for('events.edit_event', event_name=event_slug) }}" class="btn btn-secondary">Cancel</a>
    </div>
</form>

<!-- AI Assistant Modal -->
<div id="ai-assistant-modal" class="ai-assistant-modal-overlay" style="display: none;">
    <div class="ai-assistant-modal-content">
        <div class="ai-modal-header">
            <h3>AI Assistant</h3>
            <button type="button" class="close-modal-btn" aria-label="Close AI Assistant">&times;</button>
        </div>
        <div class="ai-modal-body">
            <div id="ai-input-view">
                <div class="ai-form-group">
                    <label for="feud_summary">Feud/Storyline Summary</label>
                    <textarea id="feud_summary" name="feud_summary" rows="4"></textarea>
                    <small class="text-muted">Briefly describe the ongoing feud or storyline.</small>
                </div>
                <div class="ai-form-group">
                    <label for="story_beats">Key Story Beats & Desired Outcome</label>
                    <textarea id="story_beats" name="story_beats" rows="6"></textarea>
                    <small class="text-muted">Outline specific moments, character developments, or the desired outcome.</small>
                </div>

                <hr>

                <!-- Match-specific AI Inputs -->
                <div id="ai-match-inputs" style="display: none;">
                    <h4>Match Control Panel</h4>
                    <div class="ai-control-panel">
                        <div class="ai-form-row">
                            <div class="ai-form-group">
                                <label for="detail_level">Level of Detail</label>
                                <select id="detail_level" name="detail_level">
                                    <option value="Brief Summary">Brief Summary</option>
                                    <option value="Detailed Summary">Detailed Summary</option>
                                    <option value="Play-by-Play">Play-by-Play</option>
                                </select>
                            </div>
                            <div class="ai-form-group">
                                <label for="narrative_style">Narrative Style</label>
                                <select id="narrative_style" name="narrative_style">
                                    <option value="Standard Commentary">Standard Commentary</option>
                                    <option value="Concise">Concise</option>
                                    <option value="Dirt Sheet / Tabloid">"Dirt Sheet" / Tabloid</option>
                                    <option value="Cinematic">Cinematic</option>
                                </select>
                            </div>
                        </div>
                        <div class="ai-form-row">
                            <div class="ai-form-group ai-checkbox-group">
                                <input type="checkbox" id="include_entrances" name="include_entrances">
                                <label for="include_entrances">Include Ring Entrances</label>
                            </div>
                            <div class="ai-form-group">
                                <label for="commentary_level">Commentary Level</label>
                                <select id="commentary_level" name="commentary_level">
                                    <option value="None">None</option>
                                    <option value="Some">Some</option>
                                    <option value="A lot">A lot</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Promo-specific AI Inputs -->
                <div id="ai-promo-inputs" style="display: none;">
                    <h4>Promo Control Panel</h4>
                    <div class="ai-control-panel">
                        <div class="ai-form-row">
                            <div class="ai-form-group">
                                <label for="promo_speaker">Speaker</label>
                                <select id="promo_speaker" name="promo_speaker">
                                    <option value="">-- Select Speaker --</option>
                                    <!-- Options will be populated by JS -->
                                </select>
                            </div>
                            <div class="ai-form-group">
                                <label for="promo_style">Promo Style</label>
                                <select id="promo_style" name="promo_style">
                                    <option value="Standard">Standard</option>
                                    <option value="Intense">Intense</option>
                                    <option value="Comedic">Comedic</option>
                                    <option value="Serious">Serious</option>
                                    <option value="Heelish">Heelish</option>
                                    <option value="Babyface">Babyface</option>
                                    <option value="Emotional">Emotional</option>
                                    <option value="Technical">Technical</option>
                                </select>
                            </div>
                        </div>
                        <div class="ai-form-row">
                            <div class="ai-form-group">
                                <label for="promo_detail_level">Level of Detail</label>
                                <select id="promo_detail_level" name="promo_detail_level">
                                    <option value="Brief Summary">Brief Summary</option>
                                    <option value="Detailed Summary">Detailed Summary</option>
                                </select>
                            </div>
                            <div class="ai-form-group">
                                <label for="promo_narrative_style">Narrative Style</label>
                                <select id="promo_narrative_style" name="promo_narrative_style">
                                    <option value="Standard Commentary">Standard Commentary</option>
                                    <option value="Dirt Sheet / Tabloid">"Dirt Sheet" / Tabloid</option>
                                    <option value="Cinematic">Cinematic</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="ai-modal-footer">
                    <button type="button" class="btn btn-primary" id="ai-generate-prompt-btn">Generate Prompt</button>
                    <button type="button" class="btn btn-success" id="ai-send-to-ai-direct-btn">Send to AI Directly</button>
                    <button type="button" class="btn btn-secondary close-modal-btn">Cancel</button>
                </div>
            </div>

            <div id="ai-prompt-review-view" style="display: none;">
                <div class="ai-form-group">
                    <label for="ai-prompt-textarea">Review AI Prompt</label>
                    <textarea id="ai-prompt-textarea" rows="20" readonly></textarea>
                </div>
                <div class="ai-modal-footer">
                    <button type="button" class="btn btn-primary" id="ai-send-to-ai-btn">Send to AI</button>
                    <button type="button" class="btn btn-secondary" id="ai-edit-prompt-btn">Edit Prompt</button>
                </div>
            </div>

            <div id="ai-output-view" style="display: none;">
                <div class="ai-form-group">
                    <label for="ai-response-textarea">AI Generated Text</label>
                    <textarea id="ai-response-textarea" rows="20"></textarea>
                </div>
                <div class="ai-loading-indicator" style="display: none;">
                    <div class="spinner"></div>
                    <p>Generating...</p>
                </div>
                <div class="ai-modal-footer">
                    <button type="button" class="btn btn-success" id="ai-accept-btn">Accept & Use Text</button>
                    <button type="button" class="btn btn-primary" id="ai-regenerate-btn">Regenerate</button>
                    <button type="button" class="btn btn-secondary close-modal-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- FULL JAVASCRIPT BLOCK ---
    let segmentDataFromServer = {{ segment | tojson | safe }}; // Added for AI modal context
    const allWrestlers = {{ all_wrestlers | tojson | safe }};
    const allTagTeams = {{ all_tagteams | tojson | safe }};
    const allBelts = {{ all_belts | tojson | safe }};
    // Used for per-individual/team result dropdowns
    const matchResultOptions = {{ match_result_options | tojson | safe }};
    const winnerMethodOptions = {{ winner_method_options | tojson | safe }};
    let matchDataFromServer = {{ match_data | tojson | safe }};
    
    let currentSides = matchDataFromServer.sides || [];
    let currentMatchResults = {
        winning_side_index: matchDataFromServer.winning_side_index !== undefined ? matchDataFromServer.winning_side_index : -1,
        individual_results: matchDataFromServer.individual_results || {},
        team_results: matchDataFromServer.team_results || {},
        sync_teams_to_individuals: matchDataFromServer.sync_teams_to_individuals !== undefined ? matchDataFromServer.sync_teams_to_individuals : true,
    };
    // Overall result string + winner method
    let overallMatchResult = matchDataFromServer.match_result || "";
    let winnerMethod = matchDataFromServer.winner_method || "";

    // Collect all potential speakers for promo segments
    const allPotentialSpeakers = [];
    allWrestlers.forEach(w => allPotentialSpeakers.push(w.Name));
    allTagTeams.forEach(t => allPotentialSpeakers.push(t.Name));
    allPotentialSpeakers.sort((a, b) => a.localeCompare(b));

    document.addEventListener('DOMContentLoaded', () => {
        document.body.dataset.currentSideIndex = '0';
        toggleMatchFields();
        updateChampionDisplay();
        if (document.getElementById('type').value === 'Match') {
           renderSides();
        }
        populatePromoSpeakers(); // New: Populate speakers on load
    });

    function toggleMatchFields() {
        const segmentType = document.getElementById('type').value;
        const matchFieldsDiv = document.getElementById('match-specific-fields');
        if (segmentType === 'Match') {
            matchFieldsDiv.style.display = 'block';
            if (currentSides.length === 0) {
                currentSides = [[], []];
            }
        } else {
            matchFieldsDiv.style.display = 'none';
        }

        // Control visibility of the AI Assistant button
        const aiAssistantBtn = document.getElementById('ai-assistant-btn');
        if (aiAssistantBtn) {
            if (segmentType === 'Match') { // Only show for Match type
                aiAssistantBtn.style.display = 'inline-block';
            } else {
                aiAssistantBtn.style.display = 'none';
            }
        }
    }

    function updateChampionDisplay() {
        const select = document.getElementById('match_championship');
        const display = document.getElementById('current-champion-display');
        const selectedBeltName = select.value;
        if (!selectedBeltName) {
            display.textContent = ''; return;
        }
        const selectedBelt = allBelts.find(belt => belt.Name === selectedBeltName);
        if (selectedBelt) {
            display.textContent = `Current Champion: ${selectedBelt.Current_Holder || 'Vacant'}`;
        } else {
            display.textContent = '';
        }
    }

    function _get_all_wrestlers_involved_js(sides) {
        const wrestlers = new Set();
        sides.forEach(side => side.forEach(p => wrestlers.add(p)));
        return Array.from(wrestlers);
    }

    function _get_all_tag_teams_involved_js(sides, all_tagteams_data) {
        const teams = new Set();
        const team_member_sets = {};
        all_tagteams_data.forEach(t => {
            if (t.Name && t.Members) team_member_sets[t.Name] = new Set(t.Members); // t.Members is already a list
        });
        sides.forEach(side => {
            const side_members_set = new Set(side);
            for (const team_name in team_member_sets) {
                const members_set = team_member_sets[team_name];
                if ([...members_set].every(member => side_members_set.has(member)) && members_set.size > 1) {
                    teams.add(team_name);
                }
            }
        });
        return Array.from(teams);
    }

    function renderSides() {
        const container = document.getElementById('match-sides-container');
        container.innerHTML = '';
        currentSides.forEach((side, sideIndex) => {
            const sideDiv = document.createElement('div');
            sideDiv.className = 'card mb-3';
            let participantsHtml = side.map((member, memberIndex) => `
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    <span>${member}</span>
                    <button type="button" class="btn btn-sm btn-danger" onclick="deleteParticipant(${sideIndex}, ${memberIndex})">X</button>
                </li>`).join('');
            sideDiv.innerHTML = `
                <div class="card-header bg-light d-flex justify-content-between align-items-center">
                    Side ${sideIndex + 1}
                    <div>
                        <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="setSideAsCurrent(${sideIndex})">Set as Current</button>
                        <button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteSide(${sideIndex})">Delete Side</button>
                    </div>
                </div>
                <ul class="list-group list-group-flush p-2">${participantsHtml || '<li class="list-group-item text-muted">No participants.</li>'}</ul>`;
            container.appendChild(sideDiv);
        });
        flashCurrentSide(parseInt(document.body.dataset.currentSideIndex || '0'));
        updateParticipantsDisplay();
        renderResults();
    }

    function renderResults() {
        // Overall match_result dropdown
        const overallSelect = document.getElementById('match_result_overall');
        const overallOptions = [];

        // Per-side win options
        currentSides.forEach((side, index) => {
            const names = side.join(', ');
            overallOptions.push(`Side ${index + 1} (${names}) wins`);
        });

        // Draw/No contest options
        overallOptions.push(
            "Draw (Time limit)",
            "Draw (Double disqualification)",
            "Draw (Double count out)",
            "No contest"
        );

        // Populate select
        overallSelect.innerHTML = '';
        // Default blank
        const blank = document.createElement('option');
        blank.value = '';
        blank.textContent = '-- Select Overall Result --';
        overallSelect.appendChild(blank);

        overallOptions.forEach(opt => {
            const o = document.createElement('option');
            o.value = opt;
            o.textContent = opt;
            overallSelect.appendChild(o);
        });

        // Preserve previously selected value if still valid
        if (overallMatchResult && overallOptions.includes(overallMatchResult)) {
            overallSelect.value = overallMatchResult;
        } else {
            overallSelect.value = '';
        }

        overallSelect.addEventListener('change', (e) => {
            overallMatchResult = e.target.value;
            deriveWinningSideFromOverall();
            toggleWinnerMethodVisibility();
            updateHiddenInputs();
        });

        // Winner method visibility + prefill
        toggleWinnerMethodVisibility();
        const winnerMethodSelect = document.getElementById('winner_method');
        if (winnerMethod && winnerMethodOptions.includes(winnerMethod)) {
            winnerMethodSelect.value = winnerMethod;
        }

        // Individual / Team results
        const allWrestlersInMatch = _get_all_wrestlers_involved_js(currentSides);
        const allTeamsInMatch = _get_all_tag_teams_involved_js(currentSides, allTagTeams);
        const indContainer = document.getElementById('individual-results-container');
        const teamContainer = document.getElementById('team-results-container');
        indContainer.innerHTML = '<h4>Individual Results</h4>';
        teamContainer.innerHTML = '<h4>Team Results</h4>';
        
        allWrestlersInMatch.forEach(wrestler => {
            const result = currentMatchResults.individual_results[wrestler] || 'No Contest';
            indContainer.innerHTML += `
                <div class="form-group row align-items-center mb-1">
                    <label class="col-sm-4 col-form-label text-truncate">${wrestler}</label>
                    <div class="col-sm-8">
                        <select class="form-control form-control-sm" onchange="updateIndividualResult('${wrestler}', this.value)">
                            ${matchResultOptions.map(option => `<option value="${option}" ${result === option ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
        });
        if (allWrestlersInMatch.length === 0) indContainer.innerHTML += '<p class="text-muted">No wrestlers in match.</p>';

        allTeamsInMatch.forEach(teamName => {
            const result = currentMatchResults.team_results[teamName] || 'No Contest';
            teamContainer.innerHTML += `
                <div class="form-group row align-items-center mb-1">
                    <label class="col-sm-4 col-form-label text-truncate">${teamName}</label>
                    <div class="col-sm-8">
                        <select class="form-control form-control-sm" onchange="updateTeamResult('${teamName}', this.value)">
                            ${matchResultOptions.map(option => `<option value="${option}" ${result === option ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                    </div>
                </div>`;
        });
        if (allTeamsInMatch.length === 0) teamContainer.innerHTML += '<p class="text-muted">No tag teams in match.</p>';

        // Derive winning side initially (on load)
        deriveWinningSideFromOverall();
        updateHiddenInputs();
    }

    function deriveWinningSideFromOverall() {
        // If overall result is "Side N (...) wins", set winning_side_index = N-1; else -1
        const m = /^Side\s+(\d+)\s*\(/i.exec(overallMatchResult || '');
        if (m) {
            const n = parseInt(m[1], 10);
            if (!isNaN(n) && n >= 1 && n <= currentSides.length) {
                currentMatchResults.winning_side_index = n - 1;
                return;
            }
        }
        currentMatchResults.winning_side_index = -1;
    }

    function toggleWinnerMethodVisibility() {
        const group = document.getElementById('winner-method-group');
        if (overallMatchResult && overallMatchResult.toLowerCase().includes('wins')) {
            group.style.display = 'block';
        } else {
            group.style.display = 'none';
            document.getElementById('winner_method').value = '';
            winnerMethod = '';
        }
    }

    function addParticipantToCurrentSide() {
        const selectElement = document.getElementById('participant-select');
        const selectedValue = selectElement.value;
        if (!selectedValue) return;
        const [type, name] = selectedValue.split(':');
        let membersToAdd = [];
        if (type === 'wrestler') {
            membersToAdd.push(name);
        } else if (type === 'tagteam') {
            const team = allTagTeams.find(t => t.Name === name);
            if (team && team.Members) membersToAdd = team.Members; // team.Members is already a list
        }
        const currentSideIndex = parseInt(document.body.dataset.currentSideIndex || '0');
        const targetSide = currentSides[currentSideIndex];
        if(targetSide){
            membersToAdd.forEach(member => { if (!targetSide.includes(member)) targetSide.push(member); });
            renderSides();
        }
        selectElement.value = '';
    }
    
    function addNewSide() {
        currentSides.push([]);
        setSideAsCurrent(currentSides.length - 1);
        renderSides();
    }
    
    function setSideAsCurrent(sideIndex) {
        document.body.dataset.currentSideIndex = sideIndex;
        flashCurrentSide(sideIndex);
    }
    
    function flashCurrentSide(sideIndex) {
        const sides = document.querySelectorAll('#match-sides-container .card');
        sides.forEach((div, idx) => div.classList.toggle('border-primary', idx === sideIndex));
    }

    function deleteParticipant(sideIndex, memberIndex) {
        currentSides[sideIndex]?.splice(memberIndex, 1);
        renderSides();
    }

    function deleteSide(sideIndex) {
        currentSides.splice(sideIndex, 1);
        setSideAsCurrent(Math.max(0, currentSides.length - 1));
        renderSides();
    }

    function updateParticipantsDisplay() {
        const displayElement = document.getElementById('current-participants-display');
        let sideStrings = currentSides.map(side => {
            if (side.length === 0) return '';
            const matchedTeams = _get_all_tag_teams_involved_js([side], allTagTeams);
            return matchedTeams.length > 0 ? matchedTeams.join(' & ') : side.join(', ');
        }).filter(s => s);
        displayElement.textContent = sideStrings.join(' vs ');
        document.getElementById('participants_display_input').value = displayElement.textContent;
    }

    function updateHiddenInputs() {
        // Keep winner_method synced
        const wmSelect = document.getElementById('winner_method');
        winnerMethod = wmSelect ? wmSelect.value : '';
        // Persist current results + derived winning side
        document.getElementById('match_sides_json_input').value = JSON.stringify(currentSides);
        document.getElementById('match_results_json_input').value = JSON.stringify(currentMatchResults);
        // overallMatchResult and winnerMethod are posted via named fields:
        //   name="match_result" on #match_result_overall
        //   name="winner_method" on #winner_method

        // New: Update match_visibility_json
        const matchVisibility = {
            hide_from_card: document.getElementById('hide_from_card').checked,
            hide_summary: document.getElementById('hide_summary').checked,
            hide_result: document.getElementById('hide_result').checked
        };
        document.getElementById('match_visibility_json_input').value = JSON.stringify(matchVisibility);
    }
    
    function updateIndividualResult(wrestler, result) { currentMatchResults.individual_results[wrestler] = result; updateHiddenInputs(); }
    function updateTeamResult(team, result) { currentMatchResults.team_results[team] = result; updateHiddenInputs(); }
    function updateSyncToggle(checkbox) { currentMatchResults.sync_teams_to_individuals = checkbox.checked; updateHiddenInputs(); }

    // JS version of _generate_side_display_string
    function _generateSideDisplayStringJS(side, allTagTeamsData) {
        const sideSet = new Set(side);
        const containedTeams = allTagTeamsData.filter(team => {
            const members = team.Members || []; // team.Members is already a list
            return members.length > 1 && members.every(member => sideSet.has(member));
        });
        
        const wrestlersInTeams = new Set();
        containedTeams.forEach(team => {
            (team.Members || []).forEach(member => wrestlersInTeams.add(member)); // team.Members is already a list
        });
            
        const independentWrestlers = side.filter(w => !wrestlersInTeams.has(w));
        
        const parts = [];
        containedTeams.forEach(team => {
            const membersStr = team.Members ? team.Members.join(', ') : '';
            parts.push(`${team.Name} (${membersStr})`);
        });
        
        parts.push(...independentWrestlers);
        
        return parts.join(", ");
    }

    // JS version of generate_match_result_display_string
    function generateMatchResultDisplayStringJS() {
        const sides = currentSides;
        const winningSideIndex = currentMatchResults.winning_side_index;
        const matchResultOverall = overallMatchResult;
        const currentWinnerMethod = winnerMethod; // Use the current winnerMethod from JS state
        const matchChampionship = document.getElementById('match_championship').value;
        const matchTime = document.getElementById('match_time').value;

        const displayParts = [];
        
        if (winningSideIndex !== -1 && winningSideIndex >= 0 && winningSideIndex < sides.length) {
            // It's a win/loss scenario
            const winningSideParticipants = sides[winningSideIndex];
            const losingSidesParticipants = sides.filter((_, i) => i !== winningSideIndex);

            const winnerStr = _generateSideDisplayStringJS(winningSideParticipants, allTagTeams);
            const loserStr = losingSidesParticipants.map(side => _generateSideDisplayStringJS(side, allTagTeams)).filter(s => s).join(", ");

            displayParts.push(`${winnerStr} def. ${loserStr}`);

            if (currentWinnerMethod) {
                displayParts.push(`by ${currentWinnerMethod}`);
            }

            if (matchChampionship) {
                const belt = allBelts.find(b => b.Name === matchChampionship);
                if (belt) {
                    const currentHolder = belt.Current_Holder;
                    let isRetain = false;
                    if (currentHolder) {
                        if (belt.Holder_Type === 'Tag-Team') {
                            const winningSideMembers = new Set(winningSideParticipants);
                            const teamMembers = new Set(allTagTeams.find(t => t.Name === currentHolder)?.Members || []); // Members is already a list
                            if (teamMembers.size > 0 && [...teamMembers].every(member => winningSideMembers.has(member))) {
                                isRetain = true;
                            }
                        } else { // Singles
                            if (winningSideParticipants.includes(currentHolder)) {
                                isRetain = true;
                            }
                        }
                    }
                    
                    if (isRetain) {
                        displayParts.push(`to retain the ${matchChampionship}`);
                    } else {
                        displayParts.push(`to win the ${matchChampionship}`);
                    }
                }
            }

        } else {
            // It's a draw or no contest
            if (sides.length > 0) {
                const participantDisplayForDraw = sides.map(side => _generateSideDisplayStringJS(side, allTagTeams)).filter(s => s).join(" vs ");
                if (matchResultOverall) {
                    // For draws/no contests, format as "ended in a [result]"
                    displayParts.push(`${participantDisplayForDraw} ended in a ${matchResultOverall.toLowerCase()}`);
                } else {
                    displayParts.push(participantDisplayForDraw); // Fallback if overall result is empty
                }
            } else if (matchResultOverall) {
                // If no sides but overall result exists (e.g., "No contest" without participants)
                displayParts.push(`Ended in a ${matchResultOverall.toLowerCase()}`);
            }
        }

        let finalString = displayParts.join(" ");

        if (matchTime) {
            finalString += ` (${matchTime})`;
        }
        return finalString;
    }

    function generateAndSetMatchResultDisplay() {
        matchResultDisplay = generateMatchResultDisplayStringJS();
        document.getElementById('match_result_display').value = matchResultDisplay;
    }

    // Modify renderSides to call generateAndSetMatchResultDisplay
    const originalRenderSides = renderSides;
    renderSides = function() {
        originalRenderSides();
        generateAndSetMatchResultDisplay();
    };

    // Modify updateChampionDisplay to call generateAndSetMatchResultDisplay
    const originalUpdateChampionDisplay = updateChampionDisplay;
    updateChampionDisplay = function() {
        originalUpdateChampionDisplay();
        generateAndSetMatchResultDisplay();
    };

    // Add event listener for match_time
    document.addEventListener('input', (event) => {
        if (event.target.id === 'match_time') {
            generateAndSetMatchResultDisplay();
        }
    });

    // Modify toggleWinnerMethodVisibility to update winnerMethod and call generateAndSetMatchResultDisplay
    const originalToggleWinnerMethodVisibility = toggleWinnerMethodVisibility;
    toggleWinnerMethodVisibility = function() {
        originalToggleWinnerMethodVisibility();
        // If hidden, winnerMethod is cleared, so we need to regenerate.
        // If shown, the select value might have changed, so we need to regenerate.
        winnerMethod = document.getElementById('winner_method').value; // Ensure winnerMethod is updated
        generateAndSetMatchResultDisplay();
    };

    // Add event listener for winner_method select
    document.addEventListener('change', (event) => {
        if (event.target.id === 'winner_method') {
            winnerMethod = event.target.value;
            generateAndSetMatchResultDisplay();
        }
    });

    // Update `renderResults` to include `generateAndSetMatchResultDisplay` call
    const originalRenderResults = renderResults;
    renderResults = function() {
        originalRenderResults(); // This will set up the overallSelect listener
        
        // Re-attach or ensure the overallSelect listener calls generateAndSetMatchResultDisplay
        const overallSelect = document.getElementById('match_result_overall');
        overallSelect.removeEventListener('change', handleOverallResultChange); // Remove old if exists
        overallSelect.addEventListener('change', handleOverallResultChange);

        // Initial call for winner method visibility and display string
        toggleWinnerMethodVisibility();
        generateAndSetMatchResultDisplay();
    };

    function handleOverallResultChange(e) {
        overallMatchResult = e.target.value;
        deriveWinningSideFromOverall();
        toggleWinnerMethodVisibility(); // This now calls generateAndSetMatchResultDisplay
        updateHiddenInputs();
    }

    // AI Assistant Modal Logic
    const aiAssistantModal = document.getElementById('ai-assistant-modal');
    const aiAssistantBtn = document.getElementById('ai-assistant-btn');
    const closeAiModalBtns = document.querySelectorAll('.close-modal-btn');
    const aiInputView = document.getElementById('ai-input-view');
    const aiPromptReviewView = document.getElementById('ai-prompt-review-view'); // New
    const aiOutputView = document.getElementById('ai-output-view');
    const aiGeneratePromptBtn = document.getElementById('ai-generate-prompt-btn'); // Changed
    const aiSendToAiBtn = document.getElementById('ai-send-to-ai-btn'); // New
    const aiEditPromptBtn = document.getElementById('ai-edit-prompt-btn'); // New
    const aiAcceptBtn = document.getElementById('ai-accept-btn');
    const aiRegenerateBtn = document.getElementById('ai-regenerate-btn');
    const aiResponseTextarea = document.getElementById('ai-response-textarea');
    const aiPromptTextarea = document.getElementById('ai-prompt-textarea'); // New
    const summaryTextarea = document.getElementById('summary_text');
    const aiLoadingIndicator = aiOutputView.querySelector('.ai-loading-indicator');

    let lastFocusedElement = null; // To restore focus after modal closes
    let currentPrompt = ""; // To store the generated prompt

    const aiSendToAiDirectBtn = document.getElementById('ai-send-to-ai-direct-btn'); // New

    function populatePromoSpeakers() {
        const speakerSelect = document.getElementById('promo_speaker');
        speakerSelect.innerHTML = '<option value="">-- Select Speaker --</option>';
        allPotentialSpeakers.forEach(speaker => {
            const option = document.createElement('option');
            option.value = speaker;
            option.textContent = speaker;
            speakerSelect.appendChild(option);
        });
        // If editing an existing promo, try to pre-select the speaker
        const currentSegmentType = document.getElementById('type').value;
        if (currentSegmentType === 'Promo' && segmentDataFromServer.promo_speaker) {
            speakerSelect.value = segmentDataFromServer.promo_speaker;
        }
    }

    function openAiModal() {
        lastFocusedElement = document.activeElement;
        aiAssistantModal.style.display = 'flex';
        aiInputView.style.display = 'block';
        aiPromptReviewView.style.display = 'none'; // Hide new view initially
        aiOutputView.style.display = 'none';
        aiResponseTextarea.value = ''; // Clear previous response
        aiPromptTextarea.value = ''; // Clear previous prompt

        const currentSegmentType = document.getElementById('type').value;
        const aiMatchInputs = document.getElementById('ai-match-inputs');
        const aiPromoInputs = document.getElementById('ai-promo-inputs');

        // Hide all specific input sections first
        aiMatchInputs.style.display = 'none';
        aiPromoInputs.style.display = 'none';

        // Show relevant input section based on segment type
        if (currentSegmentType === 'Match') {
            aiMatchInputs.style.display = 'block';
        } else if (currentSegmentType === 'Promo') {
            aiPromoInputs.style.display = 'block';
            populatePromoSpeakers(); // Ensure speakers are up-to-date
        } else { // For 'In-ring', 'Brawl', 'Interview', 'Video Package'
            // Show generic detail/narrative style controls if they are relevant for these types
            aiMatchInputs.style.display = 'block';
            // We might want to hide specific match-only controls within aiMatchInputs later if they are not generic.
        }

        // Focus on the first interactive element in the modal for accessibility
        const firstInput = aiInputView.querySelector('textarea, select, input, button');
        if (firstInput) firstInput.focus();
    }

    function closeAiModal() {
        aiAssistantModal.style.display = 'none';
        if (lastFocusedElement) {
            lastFocusedElement.focus(); // Restore focus
        }
    }

    aiAssistantBtn.addEventListener('click', openAiModal);
    closeAiModalBtns.forEach(btn => btn.addEventListener('click', closeAiModal));

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && aiAssistantModal.style.display === 'flex') {
            closeAiModal();
        }
    });

    async function generatePromptAndShowReview() {
        aiInputView.style.display = 'none';
        aiPromptReviewView.style.display = 'block';
        aiOutputView.style.display = 'none';
        aiLoadingIndicator.style.display = 'flex'; // Show loading indicator while generating prompt
        aiPromptTextarea.value = 'Generating prompt...';

        const feudSummary = document.getElementById('feud_summary').value;
        const storyBeats = document.getElementById('story_beats').value;
        const segmentType = document.getElementById('type').value;
        const segmentHeader = document.getElementById('header').value;

        let requestBody = {
            feud_summary: feudSummary,
            story_beats: storyBeats,
            segment_type: segmentType,
            segment_header: segmentHeader,
            position: document.getElementById('position').value,
            // Indicate that we only want the prompt, not the full AI generation yet
            get_prompt_only: true 
        };

        if (segmentType === 'Match') {
            requestBody.detail_level = document.getElementById('detail_level').value;
            requestBody.narrative_style = document.getElementById('narrative_style').value;
            requestBody.include_entrances = document.getElementById('include_entrances').checked;
            requestBody.commentary_level = document.getElementById('commentary_level').value;
            requestBody.match_sides_json = document.getElementById('match_sides_json_input').value;
            requestBody.match_results_json = document.getElementById('match_results_json_input').value;
            requestBody.match_championship = document.getElementById('match_championship').value;
            requestBody.match_time = document.getElementById('match_time').value;
            requestBody.match_visibility_json = document.getElementById('match_visibility_json_input').value;
            requestBody.participants_display = document.getElementById('participants_display_input').value;
            requestBody.overall_match_result = overallMatchResult;
            requestBody.winner_method = winnerMethod;
        } else if (segmentType === 'Promo') {
            requestBody.promo_speaker = document.getElementById('promo_speaker').value;
            requestBody.promo_style = document.getElementById('promo_style').value;
            requestBody.detail_level = document.getElementById('promo_detail_level').value;
            requestBody.narrative_style = document.getElementById('promo_narrative_style').value;
        } else {
            requestBody.detail_level = document.getElementById('detail_level').value;
            requestBody.narrative_style = document.getElementById('narrative_style').value;
        }

        console.log('AI Generate Prompt Request Body:', requestBody);

        try {
            const url = "{{ url_for('segments.ai_generate', event_slug=event_slug, position=segment.get('position', 0)) }}";
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            currentPrompt = data.prompt || "Error: Could not generate prompt.";
            aiPromptTextarea.value = currentPrompt;
        } catch (error) {
            console.error('Error generating AI prompt:', error);
            aiPromptTextarea.value = `Error generating prompt: ${error.message}. Please try again.`;
        } finally {
            aiLoadingIndicator.style.display = 'none'; // Hide loading indicator
        }
    }

    async function sendPromptToAI() {
        aiPromptReviewView.style.display = 'none';
        aiOutputView.style.display = 'block';
        aiLoadingIndicator.style.display = 'flex';
        aiResponseTextarea.value = 'Sending prompt to AI and generating response...';

        const feudSummary = document.getElementById('feud_summary').value;
        const storyBeats = document.getElementById('story_beats').value;
        const segmentType = document.getElementById('type').value;
        const segmentHeader = document.getElementById('header').value;

        let requestBody = {
            feud_summary: feudSummary,
            story_beats: storyBeats,
            segment_type: segmentType,
            segment_header: segmentHeader,
            position: document.getElementById('position').value,
            // Do not include get_prompt_only, so the backend proceeds with AI generation
        };

        if (segmentType === 'Match') {
            requestBody.detail_level = document.getElementById('detail_level').value;
            requestBody.narrative_style = document.getElementById('narrative_style').value;
            requestBody.include_entrances = document.getElementById('include_entrances').checked;
            requestBody.commentary_level = document.getElementById('commentary_level').value;
            requestBody.match_sides_json = document.getElementById('match_sides_json_input').value;
            requestBody.match_results_json = document.getElementById('match_results_json_input').value;
            requestBody.match_championship = document.getElementById('match_championship').value;
            requestBody.match_time = document.getElementById('match_time').value;
            requestBody.match_visibility_json = document.getElementById('match_visibility_json_input').value;
            requestBody.participants_display = document.getElementById('participants_display_input').value;
            requestBody.overall_match_result = overallMatchResult;
            requestBody.winner_method = winnerMethod;
        } else if (segmentType === 'Promo') {
            requestBody.promo_speaker = document.getElementById('promo_speaker').value;
            requestBody.promo_style = document.getElementById('promo_style').value;
            requestBody.detail_level = document.getElementById('promo_detail_level').value;
            requestBody.narrative_style = document.getElementById('promo_narrative_style').value;
        } else {
            requestBody.detail_level = document.getElementById('detail_level').value;
            requestBody.narrative_style = document.getElementById('narrative_style').value;
        }

        console.log('AI Send to AI Request Body:', requestBody);

        try {
            const url = "{{ url_for('segments.ai_generate', event_slug=event_slug, position=segment.get('position', 0)) }}";
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            aiResponseTextarea.value = data.summary || "No summary generated.";
        } catch (error) {
            console.error('Error generating AI content:', error);
            aiResponseTextarea.value = `Error generating content: ${error.message}. Please try again.`;
        } finally {
            aiLoadingIndicator.style.display = 'none';
        }
    }

    aiGeneratePromptBtn.addEventListener('click', generatePromptAndShowReview); // Changed
    aiSendToAiBtn.addEventListener('click', sendPromptToAI); // New
    aiEditPromptBtn.addEventListener('click', () => { // New
        aiPromptReviewView.style.display = 'none';
        aiInputView.style.display = 'block';
    });
    aiRegenerateBtn.addEventListener('click', sendPromptToAI); // Regenerate now means re-send the prompt to AI
    aiSendToAiDirectBtn.addEventListener('click', sendPromptToAI); // New: Direct send to AI

    aiAcceptBtn.addEventListener('click', () => {
        summaryTextarea.value = aiResponseTextarea.value;
        closeAiModal();
    });
</script>
{% endblock %}
